Sorting Showdown: Аналіз алгоритмів сортування (ДЗ4)

Опис завдання

Це домашнє завдання присвячене порівнянню трьох алгоритмів сортування: сортування вставками, сортування злиттям і Timsort (вбудована функція Python sorted). Мета — проаналізувати їхню продуктивність на різних наборах даних (випадкові, відсортовані, зворотно відсортовані, частково відсортовані) за допомогою модуля timeit, емпірично перевірити теоретичні оцінки складності та довести переваги Timsort завдяки гібридному підходу. Також реалізовано необов’язкове завдання: злиття ( k ) відсортованих списків із двома реалізаціями (попарне злиття та з використанням мін-груди).

Встановлення та запуск

Вимоги





Python 3.8 або новіша версія.



Бібліотеки:





matplotlib (для графіків)



numpy (для обчислень складності)



statistics (для статистичної обробки)

Встановлення залежностей

pip install matplotlib numpy

Запуск





Склонуйте репозиторій:

git clone https://github.com/your-username/goit-algo-hw-04.git
cd goit-algo-hw-04



Запустіть скрипт:

python sorting_algorithms_analysis.py

Структура коду





insertion_sort: Сортування вставками (( O(n^2) ) для випадкових даних, ( O(n) ) для відсортованих).



merge_sort: Сортування злиттям (( O(n \log n) ) для всіх випадків).



timsort_wrapper: Обгортка для Timsort (гібрид вставок і злиття).



generate_test_data: Генерація тестових даних (випадкові, відсортовані, зворотно відсортовані, частково відсортовані).



measure_time: Вимірювання часу виконання з 5 запусками, повертає середнє, стандартне відхилення та вимірювання.



run_performance_analysis: Аналіз продуктивності з виведенням і логарифмічними графіками.



create_performance_plots: Створення логарифмічних графіків продуктивності, збереження у sorting_performance.png.



create_complexity_plot: Графік теоретичних складностей (( O(n) ), ( O(n \log n) ), ( O(n^2) )), збереження у complexity_comparison.png.



analyze_complexity: Емпіричний аналіз складності з порівнянням теорії.



demonstrate_timsort_efficiency: Демонстрація переваг Timsort.



merge_k_lists: Злиття ( k ) списків попарним злиттям.



merge_k_lists_heap: Оптимізоване злиття з мін-грудою (( O(N \log k) )).



test_merge_k_lists: Тестування обох версій злиття з порівнянням продуктивності.



print_conclusions: Висновки дослідження.

Результати

Аналіз продуктивності





Тестування на масивах розміром 100, 500, 1000, 2000, 5000, 10000 елементів.



Типи даних: випадкові, відсортовані, зворотно відсортовані, частково відсортовані.



Час виміряно з 5 запусками, виведено середнє ± стандартне відхилення (мс).



Логарифмічні графіки продуктивності в sorting_performance.png показують перевагу Timsort.

Теоретична складність





Графік у complexity_comparison.png порівнює ( O(n) ), ( O(n \log n) ), ( O(n^2) ).



Емпіричні коефіцієнти в analyze_complexity підтверджують:





insertion_sort: ( O(n^2) ).



merge_sort, timsort_wrapper: ( O(n \log n) ).

Переваги Timsort





Timsort швидший за merge_sort до 3–5x, особливо на частково відсортованих даних.



Причина: адаптивність і гібридний підхід (вставки для малих підмасивів).

Необов’язкове завдання





Дві реалізації злиття ( k ) списків:





merge_k_lists: Попарне злиття.



merge_k_lists_heap: Мін-груда (( O(N \log k) )).



Тести:





[[1, 4, 5], [1, 3, 4], [2, 6]] → [1, 1, 2, 3, 4, 4, 5, 6]



[[1, 2, 3], [4, 5, 6], [7, 8, 9]] → [1, 2, 3, 4, 5, 6, 7, 8, 9]



[[1, 3], [], [2, 4, 5]] → [1, 2, 3, 4, 5]



[[10, 20, 30], [5, 15, 25], [1, 11, 21], [2, 12, 22]]



Тест продуктивності (50 списків по 100 елементів) показує прискорення merge_k_lists_heap.

Висновки





Сортування вставками:





Ефективне для малих масивів (<50 елементів).



( O(n) ) для відсортованих, ( O(n^2) ) для випадкових.



Просте, стабільне.



Сортування злиттям:





( O(n \log n) ) для всіх випадків.



Стабільне, потребує ( O(n) ) пам’яті.



Timsort:





Гібрид вставок і злиття.



Адаптивний: ( O(n) ) для частково відсортованих.



Найкращий для реальних даних.



Необов’язкове завдання:





merge_k_lists_heap ефективніший за merge_k_lists завдяки ( O(N \log k) ).



Ключовий висновок:





Timsort — стандарт Python завдяки адаптивності та оптимізації для частково впорядкованих даних, тому програмісти використовують sorted().

Репозиторій





goit-algo-hw-04



Основний файл: sorting_algorithms_analysis.py
